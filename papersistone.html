<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI è¦–è¦ºçŒœæ‹³ (Camera RPS)</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <!-- Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        body {
            margin: 0;
            background-color: #0f172a;
            font-family: system-ui, -apple-system, sans-serif;
        }

        /* Reset for emoji icons to align nicely */
        .icon-emoji {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            line-height: 1;
        }
    </style>
</head>

<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // Mock Icons (Replacing lucide-react for standalone HTML compatibility)
        const IconWrapper = ({ size = 24, className = "", children, ...props }) => (
            <span
                className={`icon-emoji ${className}`}
                style={{ fontSize: size, width: size, height: size }}
                {...props}
            >
                {children}
            </span>
        );

        const Camera = (p) => <IconWrapper {...p}>ğŸ“·</IconWrapper>;
        const RefreshCw = (p) => <IconWrapper {...p}>ğŸ”„</IconWrapper>;
        const Trophy = (p) => <IconWrapper {...p}>ğŸ†</IconWrapper>;
        const AlertCircle = (p) => <IconWrapper {...p}>â„¹ï¸</IconWrapper>;
        const Play = (p) => <IconWrapper {...p}>â–¶ï¸</IconWrapper>;
        const Hand = (p) => <IconWrapper {...p}>âœ‹</IconWrapper>;
        const Shield = (p) => <IconWrapper {...p}>ğŸ›¡ï¸</IconWrapper>;
        const Scissors = (p) => <IconWrapper {...p}>âœŒï¸</IconWrapper>;

        const CameraRPS = () => {
            // ç‹€æ…‹ç®¡ç†
            const [modelLoaded, setModelLoaded] = useState(false);
            const [cameraAllowed, setCameraAllowed] = useState(false);
            const [gameState, setGameState] = useState('loading'); // loading, ready, countdown, analyzing, result
            const [countdown, setCountdown] = useState(3);
            const [playerGesture, setPlayerGesture] = useState(null);
            const [computerGesture, setComputerGesture] = useState(null);
            const [resultMessage, setResultMessage] = useState('');
            const [scores, setScores] = useState({ player: 0, computer: 0 });
            const [debugText, setDebugText] = useState("æ­£åœ¨åˆå§‹åŒ– AI æ¨¡å‹...");
            const [showComputerHand, setShowComputerHand] = useState(false);
            const [currentDetection, setCurrentDetection] = useState('...'); // å³æ™‚é¡¯ç¤ºç›®å‰åµæ¸¬åˆ°çš„æ‰‹å‹¢

            // Refs
            const videoRef = useRef(null);
            const canvasRef = useRef(null);
            const landmarkerRef = useRef(null);
            const requestRef = useRef(null);
            const analysisTimeoutRef = useRef(null);

            // é—œéµä¿®æ­£ï¼šä½¿ç”¨ Ref ä¾†è¿½è¹¤ç‹€æ…‹ï¼Œé¿å… requestAnimationFrame é–‰åŒ…å•é¡Œ
            const gameStateRef = useRef('loading');

            // åŒæ­¥ Ref èˆ‡ State
            useEffect(() => {
                gameStateRef.current = gameState;
            }, [gameState]);

            // è¼‰å…¥ MediaPipe
            useEffect(() => {
                const loadMediaPipe = async () => {
                    try {
                        const vision = await import("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3");
                        const { HandLandmarker, FilesetResolver } = vision;

                        const filesetResolver = await FilesetResolver.forVisionTasks(
                            "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
                        );

                        landmarkerRef.current = await HandLandmarker.createFromOptions(filesetResolver, {
                            baseOptions: {
                                modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                                delegate: "GPU"
                            },
                            runningMode: "VIDEO",
                            numHands: 1,
                            minHandDetectionConfidence: 0.3,
                            minHandPresenceConfidence: 0.3,
                            minTrackingConfidence: 0.3
                        });

                        setModelLoaded(true);
                        setDebugText("æ¨¡å‹è¼‰å…¥å®Œæˆï¼Œè«‹é–‹å•Ÿæ”å½±æ©Ÿ");
                        startCamera();
                    } catch (error) {
                        console.error(error);
                        setDebugText("æ¨¡å‹è¼‰å…¥å¤±æ•—ï¼Œè«‹é‡æ–°æ•´ç†é é¢");
                    }
                };

                loadMediaPipe();

                return () => {
                    if (requestRef.current) cancelAnimationFrame(requestRef.current);
                    if (analysisTimeoutRef.current) clearTimeout(analysisTimeoutRef.current);
                };
            }, []);

            // å•Ÿå‹•æ”å½±æ©Ÿ
            const startCamera = async () => {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: {
                            width: 640,
                            height: 480,
                            facingMode: "user"
                        }
                    });

                    if (videoRef.current) {
                        videoRef.current.srcObject = stream;
                        videoRef.current.addEventListener("loadeddata", () => {
                            setCameraAllowed(true);
                            setGameState('ready');
                            setDebugText("æº–å‚™å°±ç·’ï¼è«‹å°‡æ‰‹æŒå®Œå…¨æ”¾å…¥æ¡†å…§");
                            predictWebcam();
                        });
                    }
                } catch (err) {
                    console.error(err);
                    setDebugText("ç„¡æ³•å­˜å–æ”å½±æ©Ÿï¼Œè«‹æª¢æŸ¥æ¬Šé™è¨­å®š");
                }
            };

            // é æ¸¬å¾ªç’°
            const predictWebcam = () => {
                if (!landmarkerRef.current || !videoRef.current || !canvasRef.current) return;

                const video = videoRef.current;
                const canvas = canvasRef.current;
                const ctx = canvas.getContext("2d");

                if (video.videoWidth > 0 && canvas.width !== video.videoWidth) {
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                }

                let startTimeMs = performance.now();

                try {
                    const results = landmarkerRef.current.detectForVideo(video, startTimeMs);

                    ctx.clearRect(0, 0, canvas.width, canvas.height);

                    // é¡åƒç¿»è½‰ç¹ªè£½
                    ctx.save();
                    ctx.scale(-1, 1);
                    ctx.translate(-canvas.width, 0);

                    if (results.landmarks && results.landmarks.length > 0) {
                        for (const landmarks of results.landmarks) {
                            drawConnectors(ctx, landmarks);
                            drawLandmarks(ctx, landmarks);

                            // å³æ™‚è¾¨è­˜ (ç”¨æ–¼ UI åé¥‹)
                            const gesture = recognizeGesture(landmarks);
                            if (gesture !== 'unknown') {
                                // ç‚ºäº†æ•ˆèƒ½ï¼Œä¸è¦é »ç¹ setStateï¼Œé€™è£¡ React æœƒè‡ªå‹•æ‰¹æ¬¡è™•ç†
                                setCurrentDetection(getLabel(gesture));
                            }

                            // éŠæˆ²åˆ¤å®šéšæ®µï¼šä½¿ç”¨ Ref è®€å–æœ€æ–°ç‹€æ…‹ï¼Œè§£æ±ºé–‰åŒ…å•é¡Œ
                            if (gameStateRef.current === 'analyzing') {
                                if (gesture !== 'unknown') {
                                    handleGameResult(gesture);
                                }
                            }
                        }
                    } else {
                        // æ²’æœ‰åµæ¸¬åˆ°æ‰‹çš„æ™‚å€™
                        if (gameStateRef.current === 'ready' || gameStateRef.current === 'analyzing') {
                            setCurrentDetection('...');
                        }
                    }
                    ctx.restore();
                } catch (e) {
                    console.error(e);
                }

                // åªè¦ä¸æ˜¯åœ¨çµæœç•«é¢ï¼Œå°±æŒçºŒå¾ªç’° (ä½¿ç”¨ Ref åˆ¤æ–·)
                if (gameStateRef.current !== 'result') {
                    requestRef.current = requestAnimationFrame(predictWebcam);
                } else {
                    // å¦‚æœé€²å…¥çµæœç•«é¢ï¼Œåœæ­¢å¾ªç’°ï¼Œæ¸…ç©º ref
                    if (requestRef.current) {
                        cancelAnimationFrame(requestRef.current);
                        requestRef.current = null;
                    }
                }
            };

            const drawConnectors = (ctx, landmarks) => {
                const connections =
                    [[0, 1], [1, 2], [2, 3], [3, 4], [0, 5], [5, 6], [6, 7], [7, 8], [5, 9], [9, 10], [10, 11], [11, 12], [9, 13], [13, 14], [14, 15], [15, 16], [13, 17], [17, 18], [18, 19], [19, 20], [0, 17]];
                ctx.lineWidth = 4;
                ctx.strokeStyle = "#00FF00";
                for (const [start, end] of connections) {
                    const p1 = landmarks[start];
                    const p2 = landmarks[end];
                    ctx.beginPath();
                    ctx.moveTo(p1.x * ctx.canvas.width, p1.y * ctx.canvas.height);
                    ctx.lineTo(p2.x * ctx.canvas.width, p2.y * ctx.canvas.height);
                    ctx.stroke();
                }
            };

            const drawLandmarks = (ctx, landmarks) => {
                ctx.fillStyle = "#FF0000";
                for (const point of landmarks) {
                    ctx.beginPath();
                    ctx.arc(point.x * ctx.canvas.width, point.y * ctx.canvas.height, 5, 0, 2 * Math.PI);
                    ctx.fill();
                }
            };

            // å¯¬å®¹çš„è¾¨è­˜é‚è¼¯
            const recognizeGesture = (landmarks) => {
                // æª¢æŸ¥æ‰‹æŒ‡æ˜¯å¦ä¼¸ç›´ (Tip Y < Joint Yï¼Œå‡è¨­æ‰‹å¿ƒæœå‘é¡é ­ä¸”æ‰‹æŒ‡å‘ä¸Š)
                const isFingerOpen = (tipIdx, jointIdx) => {
                    return landmarks[tipIdx].y < landmarks[jointIdx].y;
                };

                const indexOpen = isFingerOpen(8, 6); // é£ŸæŒ‡
                const middleOpen = isFingerOpen(12, 10); // ä¸­æŒ‡
                const ringOpen = isFingerOpen(16, 14); // ç„¡åæŒ‡
                const pinkyOpen = isFingerOpen(20, 18); // å°æŒ‡

                let openCount = 0;
                if (indexOpen) openCount++;
                if (middleOpen) openCount++;
                if (ringOpen) openCount++;
                if (pinkyOpen) openCount++;

                // 0 æˆ– 1 æ ¹æ‰‹æŒ‡ -> çŸ³é ­
                if (openCount <= 1) return 'rock';
                // 2 æ ¹æ‰‹æŒ‡ -> å‰ªåˆ€
                if (openCount === 2) return 'scissors';
                // 3 æˆ– 4 æ ¹æ‰‹æŒ‡ -> å¸ƒ
                if (openCount >= 3) return 'paper';

                return 'rock';
            };

            const startGame = () => {
                // é‡æ–°é–‹å§‹å‰ï¼Œå…ˆæ¸…é™¤å¯èƒ½å­˜åœ¨çš„èˆŠå¾ªç’°
                if (requestRef.current) {
                    cancelAnimationFrame(requestRef.current);
                    requestRef.current = null;
                }

                setGameState('countdown');
                // é—œéµä¿®æ­£ï¼šæ‰‹å‹•ç«‹å³æ›´æ–° Refï¼Œé˜²æ­¢ predictWebcam è®€åˆ°èˆŠçš„ 'result' ç‹€æ…‹è€Œç«‹å³åœæ­¢
                gameStateRef.current = 'countdown';

                setResultMessage('');
                setPlayerGesture(null);
                setComputerGesture(null);
                setCountdown(3);
                setShowComputerHand(true);
                setDebugText("æº–å‚™...");

                // ç«‹å³é‡æ–°å•Ÿå‹•é æ¸¬å¾ªç’°
                predictWebcam();

                let count = 3;
                const timer = setInterval(() => {
                    count--;
                    setCountdown(count);
                    if (count === 0) {
                        clearInterval(timer);
                        setGameState('analyzing');
                        // æ‰‹å‹•åŒæ­¥ Refï¼Œç¢ºä¿åˆ†æéšæ®µç‹€æ…‹æ­£ç¢º
                        gameStateRef.current = 'analyzing';

                        setDebugText("åµæ¸¬ä¸­...");
                        setShowComputerHand(false);

                        // é€¾æ™‚è™•ç†
                        if (analysisTimeoutRef.current) clearTimeout(analysisTimeoutRef.current);
                        analysisTimeoutRef.current = setTimeout(() => {
                            // é€™è£¡ä¹Ÿè¦ç”¨ Ref åˆ¤æ–·æ˜¯å¦é‚„åœ¨éŠæˆ²ä¸­
                            if (gameStateRef.current !== 'result') {
                                setGameState('ready');
                                gameStateRef.current = 'ready';
                                setDebugText("æœªåµæ¸¬åˆ°æ‰‹å‹¢ï¼Œè«‹é‡è©¦");
                                setResultMessage("æœªåµæ¸¬åˆ°æ‰‹å‹¢");
                            }
                        }, 4000);
                    }
                }, 1000);
            };

            const handleGameResult = (pGesture) => {
                if (analysisTimeoutRef.current) clearTimeout(analysisTimeoutRef.current);

                const choices = ['rock', 'paper', 'scissors'];
                const cGesture = choices[Math.floor(Math.random() * 3)];

                setPlayerGesture(pGesture);
                setComputerGesture(cGesture);

                let result = '';
                if (pGesture === cGesture) {
                    result = 'å¹³æ‰‹ï¼';
                } else if (
                    (pGesture === 'rock' && cGesture === 'scissors') ||
                    (pGesture === 'paper' && cGesture === 'rock') ||
                    (pGesture === 'scissors' && cGesture === 'paper')
                ) {
                    result = 'ä½ è´äº†ï¼ğŸ‰';
                    setScores(s => ({ ...s, player: s.player + 1 }));
                } else {
                    result = 'é›»è…¦è´äº†ï¼ğŸ¤–';
                    setScores(s => ({ ...s, computer: s.computer + 1 }));
                }

                setResultMessage(result);
                setGameState('result'); // é€™è£¡æœƒè§¸ç™¼ Ref æ›´æ–°ï¼Œå¾ªç’°æœƒåœ¨ä¸‹ä¸€å¹€åœæ­¢
                setDebugText("éŠæˆ²çµæŸ");
            };

            const getEmoji = (gesture) => {
                if (gesture === 'rock') return 'âœŠ';
                if (gesture === 'paper') return 'âœ‹';
                if (gesture === 'scissors') return 'âœŒï¸';
                return '?';
            };

            const getLabel = (gesture) => {
                if (gesture === 'rock') return 'çŸ³é ­';
                if (gesture === 'paper') return 'å¸ƒ';
                if (gesture === 'scissors') return 'å‰ªåˆ€';
                return '';
            };

            return (
                <div className="min-h-screen bg-slate-900 flex flex-col items-center py-6 px-4 font-sans text-white select-none">

                    {/* Animation Styles */}
                    <style>
                        {
                            ` @keyframes shake {
                                0% { transform: rotate(0deg); }
                                25% { transform: rotate(-10deg); }
                                50% { transform: rotate(0deg); }
                                75% { transform: rotate(10deg); }
                                100% { transform: rotate(0deg); }
                            }
                            .animate-shake {
                                animation: shake 0.5s infinite;
                            }
                            `
                        }
                    </style>

                    {/* Header */}
                    <div className="w-full max-w-2xl flex justify-between items-center mb-6 z-10">
                        <h1 className="text-xl md:text-2xl font-bold flex items-center gap-2">
                            <Camera className="text-indigo-400" />
                            AI è¦–è¦ºçŒœæ‹³
                        </h1>
                        <div className="flex gap-2 md:gap-4 text-xs md:text-sm font-medium">
                            <div className="bg-indigo-900/50 px-3 py-1 md:px-4 md:py-2 rounded-lg border border-indigo-500/30">
                                ç©å®¶: <span className="text-yellow-400 text-lg ml-1">{scores.player}</span>
                            </div>
                            <div className="bg-pink-900/50 px-3 py-1 md:px-4 md:py-2 rounded-lg border border-pink-500/30">
                                é›»è…¦: <span className="text-yellow-400 text-lg ml-1">{scores.computer}</span>
                            </div>
                        </div>
                    </div>

                    {/* Main Game Area */}
                    <div className="relative w-full max-w-2xl aspect-[4/3] bg-black rounded-2xl overflow-hidden shadow-2xl border border-slate-700">

                        {/* Webcam Layer */}
                        <div className="absolute inset-0 z-0">
                            <video ref={videoRef} className="absolute top-0 left-0 w-full h-full object-cover scale-x-[-1]" autoPlay playsInline muted />
                            <canvas ref={canvasRef} className="absolute top-0 left-0 w-full h-full object-cover pointer-events-none" />
                        </div>

                        {/* å³æ™‚è¾¨è­˜åé¥‹ (å·¦ä¸Šè§’) */}
                        {(gameState === 'ready' || gameState === 'countdown') && (
                            <div className="absolute top-4 left-4 bg-black/60 px-3 py-1 rounded-full text-xs text-white/80 backdrop-blur-sm z-10">
                                ç›®å‰åµæ¸¬: <span className="text-yellow-400 font-bold">{currentDetection}</span>
                            </div>
                        )}

                        {/* éŠæˆ²ä¸­ï¼šé›»è…¦æ–æ™ƒå‹•ç•« (å€’æ•¸æ™‚é¡¯ç¤º) */}
                        {gameState === 'countdown' && (
                            <div className="absolute right-4 bottom-4 md:right-10 md:bottom-10 z-20 opacity-80">
                                <div className="text-[8rem] md:text-[12rem] animate-shake filter drop-shadow-lg rotate-[-90deg] scale-x-[-1]">
                                    âœŠ
                                </div>
                                <p className="text-center font-bold text-white bg-black/50 rounded-full px-2">é›»è…¦æº–å‚™ä¸­...</p>
                            </div>
                        )}

                        {/* å€’æ•¸è¨ˆæ™‚å¤§å­— */}
                        {gameState === 'countdown' && (
                            <div className="absolute inset-0 flex items-center justify-center bg-black/20 z-20 backdrop-blur-[2px]">
                                <span className="text-[10rem] font-black text-white drop-shadow-[0_0_20px_rgba(255,255,255,0.8)] animate-pulse">
                                    {countdown > 0 ? countdown : ''}
                                </span>
                            </div>
                        )}

                        {/* åµæ¸¬ä¸­æç¤º */}
                        {gameState === 'analyzing' && (
                            <div className="absolute inset-0 flex items-center justify-center z-20">
                                <div className="bg-black/60 px-8 py-4 rounded-full backdrop-blur-md border border-white/20 animate-pulse text-center">
                                    <p className="text-3xl font-bold text-yellow-400">è«‹å‡ºæ‹³ï¼</p>
                                    <p className="text-sm text-white/80 mt-1">
                                        {currentDetection !== '...' ? `æˆ‘çœ‹åƒæ˜¯: ${currentDetection}` : 'å°‹æ‰¾æ‰‹éƒ¨ä¸­...'}
                                    </p>
                                </div>
                            </div>
                        )}

                        {/* Loading */}
                        {!modelLoaded && (
                            <div className="absolute inset-0 flex flex-col items-center justify-center bg-slate-900/90 z-30">
                                <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-white mb-4"></div>
                                <p className="text-indigo-200">æ­£åœ¨è¼‰å…¥ AI è¦–è¦ºæ¨¡å‹...</p>
                                <p className="text-xs text-slate-500 mt-2">é¦–æ¬¡è¼‰å…¥å¯èƒ½éœ€è¦å¹¾ç§’é˜</p>
                            </div>
                        )}

                        {/* çµæœç•«é¢ */}
                        {gameState === 'result' && (
                            <div className="absolute inset-0 flex flex-col items-center justify-center bg-slate-900/85 backdrop-blur-md z-30 animate-in fade-in duration-300">
                                <h2 className={`text-5xl font-black mb-8 drop-shadow-lg text-center px-4
                                ${resultMessage.includes('è´') ? 'text-yellow-400' : resultMessage.includes('å¹³')
                                        ? 'text-white' : 'text-red-400'}`}>
                                    {resultMessage}
                                </h2>

                                <div className="flex gap-8 md:gap-16 items-center mb-8 w-full justify-center px-4">
                                    {/* ç©å®¶çµæœ */}
                                    <div className="flex flex-col items-center">
                                        <p className="text-sm text-slate-400 mb-2 font-bold tracking-widest">YOU</p>
                                        <div className="relative">
                                            <div className="text-7xl md:text-8xl bg-indigo-600/20 p-4 rounded-3xl border-2 border-indigo-500/50 shadow-[0_0_30px_rgba(79,70,229,0.2)]">
                                                {getEmoji(playerGesture)}
                                            </div>
                                            <div className="absolute -bottom-3 left-1/2 -translate-x-1/2 bg-indigo-600 text-white text-xs px-2 py-0.5 rounded-full whitespace-nowrap">
                                                {getLabel(playerGesture)}
                                            </div>
                                        </div>
                                    </div>

                                    <div className="text-3xl font-black text-white/20 italic">VS</div>

                                    {/* é›»è…¦çµæœ */}
                                    <div className="flex flex-col items-center">
                                        <p className="text-sm text-slate-400 mb-2 font-bold tracking-widest">CPU</p>
                                        <div className="relative">
                                            <div className="text-7xl md:text-8xl bg-pink-600/20 p-4 rounded-3xl border-2 border-pink-500/50 shadow-[0_0_30px_rgba(236,72,153,0.2)]">
                                                {getEmoji(computerGesture)}
                                            </div>
                                            <div className="absolute -bottom-3 left-1/2 -translate-x-1/2 bg-pink-600 text-white text-xs px-2 py-0.5 rounded-full whitespace-nowrap">
                                                {getLabel(computerGesture)}
                                            </div>
                                        </div>
                                    </div>
                                </div>

                                <button onClick={startGame}
                                    className="flex items-center gap-2 bg-indigo-600 hover:bg-indigo-500 text-white px-8 py-3 rounded-full font-bold text-lg transition-transform active:scale-95 shadow-lg shadow-indigo-500/30">
                                    <RefreshCw size={20} />
                                    å†ç©ä¸€æ¬¡
                                </button>
                            </div>
                        )}

                        {/* é–‹å§‹æŒ‰éˆ• (Ready State) */}
                        {gameState === 'ready' && modelLoaded && cameraAllowed && (
                            <div className="absolute bottom-8 left-1/2 -translate-x-1/2 z-20 w-full px-4 flex justify-center">
                                <button onClick={startGame}
                                    className="flex items-center justify-center gap-3 bg-green-600 hover:bg-green-500 text-white w-full max-w-xs py-4 rounded-2xl font-bold text-2xl transition-all hover:scale-105 shadow-xl shadow-green-500/30 border-b-4 border-green-800 active:border-b-0 active:translate-y-1">
                                    <Play fill="currentColor" size={28} />
                                    é–‹å§‹å°æ±º
                                </button>
                            </div>
                        )}
                    </div>

                    {/* åº•éƒ¨èªªæ˜ */}
                    <div className="mt-4 flex items-center gap-2 bg-slate-800/80 py-2 px-4 rounded-full backdrop-blur-sm border border-slate-700">
                        <AlertCircle size={16} className="text-indigo-400" />
                        <span className="text-slate-300 text-sm">{debugText}</span>
                    </div>

                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<CameraRPS />);
    </script>
</body>

</html>